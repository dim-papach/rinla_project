library(RccppCNPy)
library(RccppCNPy)
library(RcppCNPy)
targets::tar_make()
library(targets)
tar_visnetwork()
tar_visnetwork(physics = TRUE)
tar_visnetwork(physics = TRUE)
targets::tar_make()
targets::tar_make()
targets::tar_make()
targets::tar_make()
targets::tar_make()
targets::tar_make()
# Plot the data of the image from get_data
plot_data <- function(file_path) {
data <- get_data(file_path)
image(t(apply(data, 2, rev)), col = gray.colors(256), axes = FALSE, main = "Image from NPY file")
}
# Plot the data of the image from get_data
plot_data <- function("cosmic_masked.npy") {
# Plot the data of the image from get_data
plot_data <- function(file_path = "cosmic_masked.npy") {
data <- get_data(file_path)
image(t(apply(data, 2, rev)), col = gray.colors(256), axes = FALSE, main = "Image from NPY file")
}
# Plot the data of the image from get_data
plot_data <- function(file_path) {
data <- get_data(file_path)
image(t(apply(data, 2, rev)), col = gray.colors(256), axes = FALSE, main = "Image from NPY file")
}
plot_data("cosmic_masked.npy")
#' Get Data from a NPY File
#'
#' This function loads data from a NPY file and returns it as a matrix.
#'
#' @param file_path A character string specifying the path to the NPY file.
#'
#' @return A numeric matrix containing the data from the NPY file.
#'
#' @examples
#' data <- get_data("path/to/file.npy")
get_data <- function(file_path) {
# Check if the file exists
if (!file.exists(file_path)) {
stop("Error: The specified file does not exist.")
}
# Load the data from the NPY file
data <- npyLoad(file_path)
# Check if the loaded data is a matrix
if (!is.matrix(data)) {
stop("Error: The loaded data is not a matrix.")
}
return(data)
}
plot_data("cosmic_masked.npy")
library(reticulate)
get_data_py <- function(file_path) {
np <- import("numpy")
data <- np$load(file_path)
return(data)
}
plot_data <- function(file_path) {
data <- get_data_py(file_path)
image(t(apply(data, 2, rev)), col = gray.colors(256), axes = FALSE, main = "Image from NPY file")
}
plot_data("cosmic_masked.npy")
tar_make()
tar_visnetwork()
tar_visnetwork(physics = TRUE)
tar_load_globals()
tar_make(fits_file_path)
tar_make(raw_data)
tar_make(raw_data)
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_visnetwork()
tar_visnetwork(physics = true)
tar_visnetwork(physics = TRUE)
tar_manifest()
tar_manifest()
tar_make()
tar_visnetwork(physics = TRUE)
tar_visnetwork(physics = TRUE)
tar_visnetwork(physics = TRUE)
tar_visnetwork(physics = TRUE)
tar_visnetwork(physics = TRUE)
tar_visnetwork(physics = TRUE)
tar_visnetwork(physics = TRUE)
tar_make()
tar_make()
library(here)
source("~/Documents/GitHub/rinla_project/INLA_pipeline.R", echo=TRUE)
source("~/Documents/GitHub/rinla_project/INLA_pipeline.R", echo=TRUE)
source("~/Documents/GitHub/rinla_project/INLA_pipeline.R", echo=TRUE)
source("~/Documents/GitHub/rinla_project/INLA_pipeline.R", echo=TRUE)
system("ldd $(which Rscript)")
system("strings /nix/store/*glibc*/lib/libc.so.6 | grep GLIBC")
source("~/Documents/GitHub/rinla_project/INLA_pipeline.R", echo=TRUE)
source("~/Documents/GitHub/rinla_project/INLA_pipeline.R", echo=TRUE)
# INLA_pipeline.R
library(INLA)
library(reshape2)
library(ggplot2)
library(viridis)
library(optparse)
# Set working directory
# this_file <- dirname(normalizePath(sys.frame(1)$ofile))
# setwd(this_file)
# Source your custom functions from R/functions.R
source("R/functions.R")
inla.setOption(num.threads = 6)
tryCatch({
# 1. Load path
file_path <- "variants/path.txt"
npy_path <- readLines(file_path, n=1)
# 2. Load and process data
raw_data <- load_npy(npy_path)
# 2.5 Plot the image
image(t(raw_data)[, nrow(raw_data):1], col = heat.colors(256), main = "Corrected Orientation")
# 3. Prepare data
inla_variables <- prepare_data(raw_data)
# 4. Validate data
check_data_validity(
valid = inla_variables$valid,
tx = inla_variables$x,
ty = inla_variables$y,
logimg = inla_variables$logimg,
img = inla_variables$img
)
# 5. Compute parameters
model_params <- compute_parameters(
valid = inla_variables$valid,
tx = inla_variables$x,
ty = inla_variables$y,
logimg = inla_variables$logimg,
weight = 1
)
# 6. Create mesh
inla_mesh <- create_inla_mesh(model_params$x, model_params$y, cutoff = 0.1)
# 7. Define SPDE model
spde_model <- define_spde_model(
inla_mesh,
nonstationary = FALSE,
p_range = c(2, 0.2),
p_sigma = c(2, 0.2)
)
# 8. Create projection matrix
projection_matrix_A <- inla.spde.make.A(inla_mesh,
loc = cbind(model_params$x, model_params$y))
# 9. Prepare model stack
print("Prepare_model_stack")
model_stack <- prepare_model_stack(
shape = 'none',
x = model_params$x,
y = model_params$y,
par = model_params$par,
A = projection_matrix_A,
spde = spde_model,
weight = 1,
xcenter = model_params$xcenter,
ycenter = model_params$ycenter
)
# 10. Run INLA model
print("INLA results")
inla_result <- run_inla_model(
stk = model_stack$stk,
par = model_params$par,
epar = model_params$epar,
spde = spde_model,
tolerance = 1e-4,
restart = 0L,
shape = 'none'
)
# 11. Project results
print("Project results")
projected_results <- project_inla_results(
mesh = inla_mesh,
res = inla_result,
xini = 0,
xfin = inla_variables$xfin,
yini = 0,
yfin = inla_variables$yfin,
xsize = inla_variables$xsize,
ysize = inla_variables$ysize,
zoom = 1,
shape = 'none',
xcenter = model_params$xcenter,
ycenter = model_params$ycenter,
eigens = model_stack$eigens
)
# 12. Collect results
print("INLA collect")
inla_results_collected <- collect_inla_results(
output = projected_results$output,
outputsd = projected_results$outputsd,
x = model_params$x,
y = model_params$y,
par = model_params$par,
epar = model_params$epar,
xsize = inla_variables$xsize,
ysize = inla_variables$ysize,
xini = 0,
xfin = inla_variables$xfin,
yini = 0,
yfin = inla_variables$yfin,
zoom = 1
)
# 13. Unscale results
unscaled_results <- unscale_collected(inla_results_collected, scaling = TRUE)
# 13.5 Plot the image
# image(t(unscaled_results)[, nrow(unscaled_results):1], col = heat.colors(256), main = "Corrected Orientation")
# 14. Save output
output_dir <- "INLA_output_NPY"
if (!dir.exists(output_dir)) dir.create(output_dir)
fname <- basename(npy_path)
out_path <- file.path(output_dir, fname)
save_npy(unscaled_results, out_path)
message("\nPipeline completed successfully. Results saved to:\n", out_path)
}, error = function(e) {
message("\nPipeline failed with error:\n", conditionMessage(e))
quit(status = 1)
})
# 1. Load path
file_path <- "variants/path.txt"
npy_path <- readLines(file_path, n=1)
source("~/Documents/GitHub/rinla_project/INLA_pipeline.R", echo=TRUE)
source("~/Documents/GitHub/rinla_project/INLA_pipeline.R", echo=TRUE)
source("~/Documents/GitHub/rinla_project/INLA_pipeline.R", echo=TRUE)
source("~/Documents/GitHub/rinla_project/INLA_pipeline.R", echo=TRUE)
targets::tar_visnetwork()
getwd()
targets::tar_visnetwork()
targets::tar_visnetwork()
library(targets)
tar_manifest()
library(targets)
targets::tar_visnetwork()
targets::tar_visnetwork(physics = TRUE)
tar_make()
tar_make()
result <- tar_read(inla_result)
result
image_values <- result$summary.random$index$mean  # Or 'sd', 'mode', etc.
image_values
image_matrix <- as.matrix(image_values)
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
unscaled_results$out
tima <- as.matrix(unscaled_results$out)
tima
image(tima)
image(t(tima), col = viridis)
image(t(tima), col = heat.colors(256))
projected_results
projected_results$output
tima <-projected_results$output
image(t(tima), col = heat.colors(256))
image(t(tima), col = heat.colors())
image(t(tima))
tima <- inla_mesh$graph
tima
image(t(tima))
library(INLAutils)
p <- autoplot(inla_result)
m <- autoplot(inla_mesh)
m
projector <- inla.mesh.projector(mesh)
library(INLA)
projector <- inla.mesh.projector(mesh)
projector <- inla.mesh.projector(inla_mesh)
projection <- projection_matrix_A
ggplot_projection_shapefile(projection, projector, mesh)
ggplot_projection_shapefile(projection, projector, mesh)
n <- 20
loc <- matrix(runif(n*2), n, 2)
crds <- loc[chull(loc), ]
SPls <- SpatialPolygons(list(Polygons(list(Polygon(crds)), ID = 'a')))
# plot
ggplot_projection_shapefile(projection, projector, SPls, mesh)
ggplot_inla_residuals(inla_result, raw_data, binwidth = 0.1)
inla_result
ggplot_inla_residuals(inla_results_collected, raw_data, binwidth = 0.1)
ggplot_inla_residuals(inla_results_collected, raw_data)
ggplot_inla_residuals(projected_results, raw_data)
projected_results
projected_results$output
image(projected_results$output)
image(t(projected_results$output))
image(inla_mesh)
p
autoplot(inla_result)
p <-autoplot(inla_result)
# Find data names with names(p[[1]]$data)
p[[1]] +
geom_line(aes(colour = var), size = 1.3) +
palettetown::scale_colour_poke(pokemon = 'Oddish', spread = 4)
targets::tar_load_globals()
targets::tar_load_globals()
targets::tar_load_globals()
library(targets)
tar_visnetwork()
tar_visnetwork(physics = TRUE)
tar_make()
tar_make()
tar_visnetwork(physics = TRUE)
tar_make()
tar_make()
View(project_inla_results)
# Replace the target list below with your own:
list(
# 1. Load the .npy file
# 1.1 read the path from the file variables/path.txt
tar_target(
file_path,
"variants/cosmic.npy",
format = "file"
),
# 2. Read and process each .npy file using Python
tar_target(
raw_data,
load_npy(file_path),
),
# 2. Prepare Data
tar_target(
#prepared_data,
inla_variables,
prepare_data(raw_data),
),
tar_target(
data_validity_check,
check_data_validity(valid = inla_variables$valid,tx = inla_variables$x,
ty = inla_variables$y,logimg = inla_variables$logimg,
img = inla_variables$img),
cue = tar_cue(mode = "always"), # Ensure it stops if data is invalid
),
tar_target(
model_params,
compute_parameters(
valid = inla_variables$valid,
tx = inla_variables$x,
ty = inla_variables$y,
logimg = inla_variables$logimg,
weight = 1, # Adjust weight as needed
)
),
tar_target(
inla_mesh,
create_inla_mesh(model_params$x, model_params$y) # Adjust cutoff as needed
),
tar_target(
spde_model,
define_spde_model(
inla_mesh,
nonstationary = FALSE,  # Adjust based on your use case
p_range = c(2, 0.2),
p_sigma = c(2, 0.2)
)
),
tar_target(
projection_matrix_A,
inla.spde.make.A(inla_mesh, loc = cbind(model_params$x, model_params$y))
),
tar_target(
model_stack,
prepare_model_stack(
shape = 'none',  # Adjust shape based on your needs: 'radius', 'ellipse', 'none'
x = model_params$x,
y = model_params$y,
par = model_params$par,
A = projection_matrix_A,
spde = spde_model,
weight = 1, # Adjust weight as needed
xcenter = model_params$xcenter,
ycenter = model_params$ycenter
)
),
tar_target(
inla_result,
run_inla_model(
stk = model_stack$stk,
par = model_params$par,
epar = model_params$epar,
spde = spde_model,
tolerance = 1e-4, # Adjust as necessary
restart = 0L, # Adjust based on your restart strategy
shape = 'none' # Adjust shape as needed
)
),
tar_target(
projected_results,
project_inla_results(
mesh = inla_mesh,
res = inla_result,
xini = 0, xfin = inla_variables$xfin,
yini = 0, yfin = inla_variables$yfin,
xsize = inla_variables$xsize,
ysize = inla_variables$ysize,
zoom = 1, # Adjust zoom as needed
shape = 'none', # Adjust shape as needed
xcenter = model_params$xcenter,
ycenter = model_params$ycenter,
eigens = model_stack$eigens
)
),
tar_target(
inla_results_collected,
project_inla_results_collect(
projected_results = projected_results,
mesh = inla_mesh,
spde = spde_model,
model_params = model_params,
inla_result = inla_result,
shape = 'none',  # Should match your projection parameter
xcenter = model_params$xcenter,
ycenter = model_params$ycenter
)
),
tar_target(
unscalled_results,
unscale_collected(inla_results_collected, scaling = TRUE),
),
# 3. Plot the results with image()
# tar_target(
#   ploting,
#   image(t(unscaled_results$out), col = heat.colors(256), main = "Corrected Orientation")
#
# ),
#
# 4. Save the result using the same file name
tar_target(
save_results,
{
fname <- basename("TESTTIIIING")  # extract just the filename
out_path <- file.path("INLA_output_NPY", fname)
dir.create("INLA_output_NPY", showWarnings = FALSE)
save_npy(unscalled_results, out_path)
out_path
},
format = "file"
)
)
tar_make()
tar_make(projected_results)
tar_visnetwork()
tar_load_globals()
tar_make()
tar_make()
View(project_inla_results_collect)
tar_make()
tar_make()
tar_visnetwork()
tar_visnetwork()
tar_make()
tar_visnetwork()
tar_load_everything()
res <- tar_load(inla_results_collected)
projected_results
image(projected_results$out)
image((projected_results$out))
image(as.matrix(projected_results$out))
inla_results_collected$out
image(inla_results_collected$out)
image(t(inla_results_collected$out))
tar_visnetwork()
proj <- tar_load(projected_results)
proj$out
tar_visnetwork()
tar_visnetwork()
tar_make()
tar_make()
tar_make()
tar_visnetwork()
unscaled_results$out
image(unscaled_results$out)
image(t(unscaled_results$out))
tar_visnetwork()
tar_make()
tar_load_everything()
image(tar_load(unscaled_results)$out)
tar_load(unscaled_results)
tar_read(unscaled_results)
tar_read(unscaled_results)
tar_read(inla_results_collect)
tar_visnetwork()
tar_make()
tar_visnetwork()
tar_read(unscaled_results)
tar_load(unscaled_results)
tar_load(unscalled_results)
un = tar_load(unscalled_results)
un$out
un <- tar_load(unscalled_results)
un
tar_load(unscalled_results)$out
View(unscalled_results)
un <- tar_read(unscalled_results)
image(un$out)
